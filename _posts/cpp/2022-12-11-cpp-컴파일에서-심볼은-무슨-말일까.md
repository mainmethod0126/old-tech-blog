---
layout: post
title: C++ 컴파일에서 심볼은 무슨 말일까?
tags: [cpp, note]
skills: [cpp]
author: mainmethod0126
excerpt_separator: <!--more-->
---


# 서론

팀장님과 컴파일러에 대한 얘기 중 심볼이라는 키워드를 알게되었습니다. 지나가는 얘기로 시간이 여유롭지 않아, 자세히 물어보지 못하였으니 심볼이 무엇인지 이해하기 위하여 직접 찾아보았습니다.

## C++ 컴파일의 결과물

C++ 을 컴파일하게되면 출력물로 OS에서 실행할 수 있는 `기계어 코드`로 만들어진 실행 파일이 생성됩니다.
이 실행 파일의 확장자는 운영체제(OS)에 따라 다를 수 있는데, 기본적으로 Windows는 **`.exe`** 확장자의 실행 파일을, Linux및 Unix 계열의 운영 체제는 `.out` 이라는 확장자의 실행파일이 만들어지는 것이 보편적인 경우 입니다.
물론 컴파일러에 따라서 옵션으로 컴파일 시 어떤 확장자의 파일을 만들어 낼 것인지 정할 수 있게 해주는 컴파일러도 존재합니다.

## 컴파일러의 옵션에 따른 확장자 선택의 예

```bash
g++ -o myprogram.exe mysourcefile.cpp
```

위에서 이 실행 파일들은 `기계어 코드` 로 만들어졌다고 말씀 드렸는데, 좀 더 상세히 살펴보면 `기계 명령어` 와 `심볼` 로 이뤄져 있습니다.

## 기계 명령어

`기계 명령어`는 프로그램이 실행될 때 컴퓨터의 프로세서에 의해 실행되는 저수준(low level)의 코드입니다.
이러한 `기계 명령어`는 `산술 계산 수행`,`메모리 조작`,`코드의 다른 부분으로의 분기` 와 같은 작업에 해당합니다.

`기계 명령어`는 일반적으로 `니모닉 코드(mnemonic)` 와 `숫자 피연산자의 조합`을 사용하여 개별 명령어를 나타내는 `어셈블리 언어`로 작성되는데
이렇게 작성된 `어셈블리 언어`를 어셈블러가 `기계 명령어`로 변환해줍니다.

우리가 일반적으로 알고있는 컴파일 과정은
개발자가 작성한 `소스코드` > `어셈블리어 코드` > `기계 코드` 의 과정을 거치는데.

당연히 `기계 명령어`를 만들어주는 `어셈블리 언어`는 개발자가 작성한 `소스코드`를 기반으로 합니다.

### 소스코드 TO 어셈블리어 코드 예시

```CPP
// 개발자가 작성한 소스코드
#include <iostream>

using namespace std;

int main()
{
    cout << "Hello, world!" << endl;
    return 0;
}
```

위 소스코드를 어셈블리로 변환하면 아래와 같습니다.

```asm
; Assembly code generated by the C++ compiler

; Set up the stack and registers
push    rbp
mov     rbp, rsp
sub     rsp, 16

; Call the cout object's operator<< function to print "Hello, world!"
mov     edi, OFFSET FLAT:.LC0
call    operator<<(std::basic_ostream<char, std::char_traits<char> >&, char const*)

; Call the cout object's operator<< function to print a newline
mov     edi, OFFSET FLAT:.LC1
call    operator<<(std::basic_ostream<char, std::char_traits<char> >&, char const*)

; Return from main with a value of 0
xor     eax, eax
leave
ret
```

### 니모닉 코드 (또는 니모닉 심볼)
위에서 `니모닉 코드`와 `숫자 피연산자` 가 함께 어셈블리 언어에서 `기계 명령어`를 나타낸다고 설명했습니다.
이중에서 `니모닉 코드`는 프로세서가 수행할 수 있는 `특정 작업을 나타내는 짧고 상징적인 이름`입니다.
예를 들어 위 예시코드의 `mov`, `call`,`push` 등 이 니모닉 코드라 할 수 있는데, 각 니모닉 코드 뒤에는 일반적으로 코드가 나타내는 `작업의 특정 세부 정보를 지정`하는 `하나 이상의 숫자 피연산자`가 따라 옵니다.

예를 들어 보면 `mov` 다음에는 `이동할 값의 소스`와 `대상을 지정하는 두 개의 피연산자`가 올 수 있고,
`call` 다음에는 `호출할 함수의 주소`를 지정하는 `단일 피연산자`가 올 수 있습니다.

위 예시의 일부분을 확인해보면 이 말이 사실인 걸 확인할 수 있습니다.

```asm
; Call the cout object's operator<< function to print "Hello, world!"
mov     edi, OFFSET FLAT:.LC0
call    operator<<(std::basic_ostream<char, std::char_traits<char> >&, char const*)
```

지금 까지 `기계어 코드`를 이루는 `기계 명령어` 와 `심볼` 중에 `기계 명령어`를 알아보았습니다. 이어서 우리가 정말 알고자 했던 `심볼`을 알아보겠습니다.

### 심볼

`기계어 코드`에서 `심볼` 이라 하면 일반적으로 `소스코드`에서 사용되는 `함수`,`변수`, 및 `개체의 이름`을 나타냅니다.
이러한 `심볼`은 컴파일 프로세스 중에 `메모리의 해당 값` 또는 `함수에 대한 참조`로 대체됩니다.
이를 통해 `기계어 코드`는 `메모리 주소`나 `기타 구현 세부 정보`가 아닌 **`이름!!`**으로 `값`과 `함수`에 엑세스할 수 있습니다. 