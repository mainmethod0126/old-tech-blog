---
layout: post
title: 8장 빈 생명주기 콜백
tags: [spring, temp, note]
skills: [java, spring]
author: mainmethod0126
excerpt_separator: <!--more-->
---

# 빈 생명주기 콜백

인프런 김영한님의 스프링 핵심 원리 - 기본편 8장 빈 생명주기 콜백 정리했으며 본인이 핵심이라고 생각하지 않은 부분에 대해서는 과감하게 생략하였습니다.
<!--more-->

## 스프링 빈의 라이프사이클

**생성자 주입**을 제외!! 한 생성자 주입 방식들은

**`객체 생성` -> `의존관계 주입`** 과정을 거쳐 빈이 먼저 생성된 후 의존성이 필요한 빈들을 주입 받게 됩니다.

```java

@Component
public class TempMyBean {
    @Autowired
    private TestObject testObject;
}
```

예를 들어 위의 샘플 코드와 같이 **TempMyBean** 이란 클래스의 객체가 빈 컨테이너에 등록 될 때, 생성자가 호출되어 **TempMyBean** 타입의 객체가 먼저 생성이 완료되고나서 TempMyBean 이 의존성을 갖는 **testObject** 를 주입받습니다.

## 스프링 빈의 이벤트 라이프 사이클

**스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입(`                                                         생성된 빈이 필요로하는 의존성들) -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료**

**초기화 콜백** : 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출
**소멸전 콜백** : 빈이 소멸되기 직전에 호출

## 스프링이 지원하는 3가지의 대표적인 빈 생명주기 콜백

- **인터페이스(InitializingBean, DiposableBean)**
- **설정 정보에 초기화 메서드, 종료 메서드 지정**
- **@PostConstruct, @PreDestory 애노테이션 지원**

### 인터페이스(InitializingBean, DiposableBean)

Spring 에서 지원하는 `InitializingBean`, `DiposableBean` 두 인터페이스를 구현하도록 하면 `초기화 콜백`, `소멸전 콜백` 을 직접 구현할 수 있다, 하지만 위 방법은 2003년도에 나온 레거시한 방법이기에 이런 방법이 있다고만 알고 넘어가겠습니다.

### 설정 정보에 초기화 메서드, 종료 메서드 지정

빈 등록 시 `초기화 메서드`, `소멸자 메소드` 를 등록할 수 있습니다.

#### @Bean(initMethod = "init", destroyMethod = "close")

```java
@Configuration
static class LifeCycleConfig {
    @Bean(initMethod = "init", destroyMethod = "close")
    public NetworkClient networkClient() {
        NetworkClient networkClient = new NetworkClient();
        networkClient.setUrl("http://hello-spring.dev");
        return networkClient;
    }
}
```

위와 같이 `@Configuration` 빈 설정 클래스를 통한 Bean 생성 및 등록 시,
**@Bean(initMethod = "init", destroyMethod = "close")** 을 통하여 NetworkClient 클래스의 `init()` 과 `close()` 두 메소드를 각 `초기화, 소멸자` 로 등록할 수 있습니다.

##### 특징!

- 설정 정보 사용 특징
- 메서드 이름을 자유롭게 줄 수 있다.
- 스프링 빈이 스프링 코드에 의존하지 않는다.
- 코드가 아니라 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료
메서드를 적용할 수 있다

##### 종료 메서드 추론

`destroyMethod = ` 를 별도로 정의하지 않을 경우 기본적으로 `close()`, `shutdown()` 이라는 메서드를 찾아서 `소멸전 콜백` 메서드로 등록합니다.

만약 추론 기능을 사용하기 싫다면 `destroyMethod = ""` 과 같이 공백 처리하면 됩니다.

하지만 이 방식도 별로 안씁니다.

### @PostConstruct, @PreDestory 애노테이션

애노테이션 이름부터 확실하다. `PostConstruct = 생성자 이후`, `PreDestory = 소멸전`
딱 봐도 어떻게 쓰면 될지 느낌이 옵니다.

```java
 @PostConstruct
 public void init() {
    System.out.println("NetworkClient.init");
    connect();
    call("초기화 연결 메시지");
 }


 @PreDestroy
 public void close() {
    System.out.println("NetworkClient.close");
    disConnect();
 }
```

위와 같이 각 메서드의 목적에 맞게 `@PostConstruct` 와 `@PreDestroy` 를 지정해주면 간단하게 완료됩니다.

#### 특징!

- 패키지를 잘 보면 javax.annotation.PostConstruct 이다. 스프링에 종속적인 기술이 아니라 JSR-250
라는 자바 표준이다. 따라서 스프링이 아닌 다른 컨테이너에서도 동작한다

- 유일한 단점은 외부 라이브러리에는 적용하지 못한다는 것이다. 외부 라이브러리를 초기화, 종료 해야 하면
@Bean의 기능을 사용하자

> **왜? 외부 라이브러리를 못쓰지?**
> 외부 라이브러리의 코드를 수정해서  `@PostConstruct` 와 `@PreDestroy` 같은 어노태이션을 붙일 수 없기 때문에


- 컴포넌트 스캔과 잘 어울린다