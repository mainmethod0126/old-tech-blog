---
layout: post
title: Elasticsearch에서 deep paging search 구현하느라 고생하기
tags: [elasticsearch]
skills: [elasticsearch]
author: mainmethod0126
excerpt_separator: <!--more-->
---

## Deep Paging Search 란

인터넷을 하다보면 이런 화면을 여럿 보셨을 겁니다.
![picture 1](../../images/7d267196895c1945f7f821d2b448533a9893b28fde960760fd51d10effa64e9b.png)  
![picture 2](../../images/ed53fa1a67db903d90e9153d8b09c296d73707ff1e037dbe41acca801a1e867a.png)  

화살표를 통하여 현재 보고있는 페이지를 이동하는 것, 우측으로 갈 수록 점점 높은 숫자의 페이지로 이동하고 보고자 하는 내용은 더 오래된, 더 내가 원하는 내용과는 거리가 먼 그런 데이터가 노출되는 페이지로 이동하게 됩니다.

페이지를 우측으로 이동할 수록 더 깊숙히 있는 정보를 조회하는 느낌이 듭니다.
단순 10의 자리 많아야 100의 자리 페이지를 조회하는데는 큰 문제가 없을 수 있습니다.

하지만 만약 **9999999 번째 페이지** 를 조회하면 어떻게 될까요?

만약 이 페이징의 기준이 **데이터가 적재된 순서** 라고 하면 서버는 **1~9999999번 째 페이지에 해당하는 모든 정보를 데이터가 적재된 순서로 정렬해야합니다.**

그래야 가장 최근에 적재된 데이터를 1번 페이지로, 가장 오래전에 적재된 데이터를 9999999 페이지로 보여줄 수 있겠죠.

한 페이지에 10개의 데이터를 보여준다고 했을 때 대략 **구천만개 이상**의 데이터를 정렬해야합니다.

검색을 시도한 사용자에게 페이징 기능을 제공하기 위해서는 **최소한 한번의 정렬** 은 이뤄저야합니다.

여기서 잠시 페이징 검색의 요구사항을 하나 짚어보겠습니다

- **첫 조회 후 페이징된 데이터는 실시간으로 변하면 안된다.**

만약 사용자가 **"치킨"** 이라는 키워드를 검색하였는데, 때마침 월드컵 시즌이라 순식간에 **"치킨"** 이라는 데이터가 폭발적으로 적재되었다고 가정합니다.

사용자가 검색했을 때 페이지가 총 **5페이지** 였는데 **1번 부터 5번 페이지** 까지 이동하는 동안 페이지가 계속 늘어나서 순식간에 **9999999 번째 페이지가 생성되었습니다**

그럼 이 데이터 역시 **데이터가 적재된 순서**에 따른 페이징이라면, 방금전까지 보고있던 5번 페이지의 데이터가 뒤로 쭉쭉 밀려 9999999번째 페이지까지 이동 될 겁니다.

그러면 사용자는 **"어라? 5번 페이지에서 봤던 내용이 또 나오네?"** 라는 불편을 겪게되겠죠.

그렇기 때문에 페이징 검색의 경우 재검색을 시도하지 않을 때는 페이징된 내용이 유지되어야 합니다. 검색 키워드와 일치하는 데이터가 실시간으로 추가된다 하더라도 이미 검색되어진 정보는 유지되어야하죠

즉 사용자가 검색을 시도한 시점의 검색 결과를 어딘가에 **캐싱**해둬야한다는 말 입니다.

이때 Elasticsearch에서는 문제가 발생하는데, RDBMS와 비교를 통해 알아보겠습니다.

## RDBMS VS Elasticsearch

RDBMS와 Elasticsearch의 가장 큰 차이는 서비스 자체의 **목적**이 다르다는 겁니다

||RDBMS|Elasticsearch|
|---|---|---|
|목적|관계형 데이터 베이스|검색 엔진|

RDBMS의 경우 **데이터 베이스** 로 사용되기 위한 목적을 가진 서비스입니다.

흔히들 말하는 **ACID규칙**을 지키는 서비스입니다.

> **나무위키 ACID**
> **원자성 (原子性, Atomicity):** 한 트랜잭션의 모든 작업이 수행되든지, 아니면 하나도 수행되지 않아야 한다. 트랜잭션이 제대로 실행되지 않았으면 롤백(roll back)한다.
**일관성 (一貫性, Consistency):** 모든 트랜잭션은 데이터베이스에서 정한 무결성 (無缺性, integrity) 조건을 만족해야 한다.
**격리성 (隔離性, Isolation):** 두 개의 트랜잭션이 서로에게 영향을 미칠 수 없다. 트랜잭션이 실행되는 동안의 값은 다른 트랜잭션이 접근할 수 없어야 한다.
**내구성 (耐久性, Durability):** 트랜잭션이 성공적으로 끝난 뒤에는, (시스템 실패가 일어나더라도) 그 결과가 데이터베이스에 계속 유지되어야 한다.

반면에 Elasticsearch는 **검색 엔진** 입니다.

저희가 주로 사용하는 **구글, 네이버** 등의 검색 사이트를 보면

**검색 키워드와 `관련성이 높은!` 데이터를 `빠르게!` 조회한다** 를 궁극적이고 원초적인 목적으로 갖고있습니다.

이를 가능케 하기 위해서 존재하는게 **검색 엔진** 이고요

극단적으로 구분하자면

- RDBMS : **안전이 최고다!** 다른건 그 이후 얘기
- Elasticsearch : **속도가 최고다!** 다른건 그 이후 얘기

### 그럼 Elasticsearch에서는 속도를 높이기 위해서 무슨일이 벌어지나?
















## Elasticsearch Deep Paging Search 해도 되는건가?

Elasticsearch에서 깊은 검색을 해보신분이라면 저와 같은 의문을 느껴보신 분이 계실겁니다.

**"이렇게 해도 되는건가?"**









### 일단 결론

Deep Paging Search 를 하지 말자!

왜 이런 결론이 나왔는지를 이제부터 저의 경험을 예시로 설명드리겠습니다.



